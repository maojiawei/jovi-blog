---
title: "微服务架构系列：服务远程调用"
date: 2019-11-27T15:18:17+08:00
draft: false
categories: "microservice"
toc: true
---
&emsp;在服务消费者通过注册中心获得了服务提供者的地址后，服务消费者就可以向提供者的地址进行请求了。

&emsp;在单体应用时，一次服务的调用在同一台机器上的同一个进程内，我们叫做**本地方法调用**。但在微服务中，服务进行了拆分，服务的提供者和服务的消费者在运行在不同的物理机的不同进程内，这种我们称为**远程方法调用**，简称为RPC(Remote Producedure Call)。

### 1.0 RPC调用过程

&emsp;我们一般把服务消费者叫作客户端，服务提供者叫作服务端，两者通常位于网络的不同地址上。为了完成RPC调用，首先需要建立网络连接。建立连接后，双方需要按照某种约定的协议进行网络通信，我们叫做**通信协议**。在建立正常通信后，服务端接收请求，处理请求，并将结果返回给客户端。为了减少传输的数据大小，还要对数据进行压缩，这叫做**数据序列化**。

&emsp;根据以上过程，我们可以看出四种问题？

- 如何建立连接？
- 服务端如何处理请求？
- 数据传输采用什么协议？
- 数据序列化方式？

### 2.0 服务连接

一般来说，客户端与服务端之间建立网络连接有两种常用的途径：

#### 2.1 HTTP

&emsp;HTTP是一种应用层协议，主要基于TCP协议，规定了数据传输的格式。现在大部分客户端浏览器与服务端通信基本都是采用HTTP协议的方式。

&emsp;HTTP协议建立通信的机制一般都是采用[三次握手]( https://condor.depaul.edu/jkristof/technotes/tcp.html )和四次挥手的方式进行的。

#### 2.2 socket

&emsp;Socket通信是基于TCP/IP协议的封装，建立一次Socket连接至少需要一堆套接字。第一个运行于客户端，称为clientSocket；另一种运行于服务端，称为serverSocket。Socket通信需要经过以下四个步骤:

1. 服务器监听：ServerSocket通过调用bind()函数绑定某个具体的端口，然后调用listen()函数实时监控网络状态，等待客户端的连接。
2. 客户端请求：ClientSocket调用connect()函数向ServerSocket绑定的地址和端口发起连接请求。
3. 服务端连接确认：当ServerSocket监听到或者接收到ClientSocket的链接请求时，调用accept()函数响应ClientSocket的请求，同客户端建立连接。
4. 数据传输：当 ClientSocket 和 ServerSocket 建立连接后，ClientSocket 调用 send() 函数，ServerSocket 调用 receive() 函数，ServerSocket 处理完请求后，调用 send() 函数，ClientSocket 调用 receive() 函数，就可以得到得到返回结果。

&emsp;下图展示了客户端与服务端之间连接的过程。

![socket连接](../images/microservice/socket_connect.jpg)



### 3.0 服务端处理请求的方式

&emsp;当客户端与服务端之间建立请求之后，服务端一般会采用以下三种方式来处理请求:

-  **同步阻塞方式（BIO） ：**客户端每次发送一个请求，服务端就会生成一个线程去处理。这种常用于连接数比较小的业务场景。
-  **同步非阻塞方式 (NIO) ：**客户端每次发送一个请求，服务端不会创建新线程来处理，而是通过I/O多路复用技术来处理（多个堵塞复用到同一个select堵塞）。因此，服务端可以用一个线程处理多个客户端请求。 这种适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。 
- **异步非堵塞（AIO）：**客户端只需要发起一个 I/O 操作然后立即返回，等 I/O 操作真正完成以后，客户端会得到 I/O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，适用于连接数多，消耗比较重的业务场景，这样就不存在阻塞等待问题。

### 4.0 数据传输协议

&emsp;在数据传输协议中，最常用的是HTTP协议，这是一种开放的协议。当然还有一些其他的定制私有协议，例如阿里巴巴的Dubbo协议。

&emsp; 论是开放的还是私有的协议，都必须定义一个“契约”，以便服务消费和服务提供者之间能够达成共识。服务消费者按照契约，对传输的数据进行编码，然后通过网络传输过去；服务提供者从网络上接收到数据后，按照契约，对传输的数据进行解码，然后处理请求，再把处理后的结果进行编码，通过网络传输返回给服务消费者；服务消费者再对返回的结果进行解码，最终得到服务提供者处理后的返回值。 

&emsp; 通常协议契约包括两个部分：消息头和消息体。其中消息头存放的是协议的公共字段以及用户扩展字段，消息体存放的是传输数据的具体内容。 

### 5.0 数据序列化

&emsp;在网络传输过程中，发送方会先对数据进行编码，再经过网络传输至另一端后，再对数据进行解码。这个过程，叫做序列化与反序列化。序列化的目的是为了减小数据传输量，加快网络传输速度。

&emsp;常用的序列化方式分为两类：**文本类（XML/JSON）** 以及   **二进制类（ PB/Thrift/hessian）**。具体采用哪种格式，取决于三个方面的因素。

- **支持数据格式的种类。**数据种类支持的越多，在编码时会更加友好。
- **跨语言支持。**跨语言支持是一个重要因素，否则使用场景会比较局限。
- **性能。**性能主要看两点，一种是序列化后的压缩比，另一种是序列化速度。
- **序列化后的可读性。**如果需要对外部提供服务，可读性是一个重要因素。文本类的序列化方式，相对而言可读性较高。



