---
title: "布隆过滤器（Bloom Filter）"
date: 2019-12-04T16:04:55+08:00
draft: false
categories: "microservice"
toc: true
---
&emsp;布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

### 1.0 散列表
&emsp;散列表(Hash table,也叫哈希表)是一种常用的数据结构。其实它是一种数组的拓展，如下图所示，当我们需要插入一个数据的时候，我们可以通过哈希函数进行运算，根据得出的值存放至数组中。

&emsp;同样的道理，当我们需要查询一个数据的时候，只需要先进行hash函数，再去对应的数组下标中匹配。如果成功，即返回。时间复杂度是O(1)。
![哈希表](../images/filter/哈希表.jpg)

&emsp;然而，这是最理想的情况。任何的哈希函数都会存在哈希冲突，因为哈希函数计算得出的结果长度是一致的，导致两个或以上的数据在哈希函数计算后会出现一样的结果。当然，哈希表有对应的方案处理这个问题，分别为开放寻址法和链表法。（这两个方案不在本章讨论的范围内，感兴趣的大家可以自行寻找资料学习。）

### 2.0 布隆过滤器（Bloom Filter）
&emsp;哈希表主要是用来高效的存储数据，而布隆过滤器可以检查值是否"可能存在集合中"。这里的"可能"说明布隆过滤器存在一定的误判率。因此,Bloom Filter不适合那些对错误"零容忍"的场合，但**在低容忍的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。**

&emsp;下面我们来看布隆过滤器是如何实现的。初始状态下，布隆过滤器是一个包含m为的位数组，每一位位置都是0。

![布隆过滤器初始状态](../images/filter/布隆过滤器初始状态.jpg)

&emsp;我们可以往布隆过滤中存入值。我们在哈希表中提到过，我们采用的是哈希函数，输出了对应的索引值。那么布隆过滤器为了提高匹配率，他可以支持n个相互独立的哈希函数，分别映射到对应的数组下标中。

&emsp;例如本例中，我们采用了三个哈希函数，分别对jovi进行hash运算，得出1、3、7；对io进行hash运算，得出0、3、6。我们将这些下标对应的值改为1,注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。

![布隆过滤器数据保存](../images/filter/布隆过滤器数据保存.jpg)

&emsp;当我们需要判断一个数据是否在布隆过滤器的时候，我们需要取n次哈希函数，如果n次哈希函数得出的下标，对应的元素都是1的话，则说明匹配成功。反之，如果有一个不是1，则失败。

&emsp;下图中，jovi得出的结果是1、3、7，必然都是1，匹配成功。pub进行计算后的结果为1、4、9，其中4和9都是0，即失败。

![布隆过滤器数据校验](../images/filter/布隆过滤器数据校验.jpg)

&emsp;由此可见，布隆过滤器是有误报的，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。幸运的是，布隆过滤器有一个可预测的误判率（FPP）：
![布隆过滤器误判率](../images/filter/布隆过滤器误判率.webp)

- n 是已经添加元素的数量；
- k 哈希的次数；
- m 布隆过滤器的长度（如比特数组的大小）

&emsp;极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。

&emsp;实际情况中，布隆过滤器的长度 m 可以根据给定的误判率（FFP）的和期望添加的元素个数 n 的通过如下公式计算：

![布隆过滤器长度计算公式](../images/filter/布隆过滤器长度计算公式.webp)

### 3.0 应用
&emsp;布隆过滤器一般用于大量数据下，判断给的数据都是在其中。例如:

- 网页爬虫对URL去重
- 反垃圾邮件、短信等
- 避免推荐用户已经购买过的商品

### 4.0 相关资料
[5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！](https://mp.weixin.qq.com/s/AFbE0E65SR85NfZVTDPazw)

[布隆过滤器原理](https://blog.csdn.net/a308601801/article/details/87074273)


