---
title: "redis入门实战之九:Redis的缓存问题"
date: 2019-05-14T22:01:27+08:00
draft: false
tags: ["redis"]
categories: "microservice"
toc: true
---
&emsp;目前平常在项目中都会大量使用redis作为缓存，因为一些数据没有必要每次查询都要请求数据库。但在某些情况可能会出现缓存失效的情况。本文将从【缓存雪崩】，【缓存击穿】，【缓存穿透】和【热点数据失效】这几个问题来如何解决和设计缓存问题。  

## 1.0 缓存击穿
&emsp;缓存击穿是指存在一些热点的数据，在其失效之后，这些数据被超高并发的访问。  
&emsp;解决方案:  
1.对于主打的热点商品替换缓存，并设置永远缓存。  
2.采用互斥锁。先使用当缓存失效时，先不去数据里面获取数据，而是通过redis的setnx机制，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。如果已经存在另一个线程正在往缓存里面塞入数据，那等待后重新读取缓存；如果没有，则自己写入。
```java
public String get(key) {  
      String value = redis.get(key);  
      //value往缓存中读取数据
      if (value == null) { 
          //设置一个1分钟的key_mutex的锁
          //如果返回1，则说明没有线程在处理缓存写入，则需要自己处理
          if (redis.setnx(key_mutex, 1, 1 * 60) == 1) {  
               value = db.get(key);  
               redis.set(key, value, expire_secs);  
               redis.del(key_mutex);  
          } else { 
              //如果为0，那说明已经有线程开始处理缓存了，只需要等待重试即可
              sleep(50);
              //重试 
              get(key); 
          }  
      } else {  
          return value;        
      }  
 }  
```

## 2.0 缓存雪崩
&emsp;缓存雪崩是指在某个时间内大量数据缓存过期，导致缓存在某一时刻同时失效，请求全部转发至DB，造成DB瞬时压力过大。  
&emsp;例如：双十一零点，大量商品集中放入缓存中，假设缓存30分钟，那么到了12点半的时候，这批商品的缓存过期了。那么同一时间对这批商品的访问流量又落到了数据库中，对数据库而言，产生了周期性的压力波峰。  
&emsp;解决方案:  
1.针对不同分类的缓存种类，根据热门和冷门设置不同的缓存时间。  
2.针对同一种类的商品，设置一个随机因子，尽可能的分散缓存过期时间。  

## 3.0 缓存穿透
&emsp;正常的缓存流程是:先从缓存中读取，如果缓存存在，直接返回结果；如果缓存不存在，再从数据库中获取，再存入缓存中，再返回结果。  
&emsp;缓存穿透是指有一个数据库不存在的数据，但是一直被请求。由于这个不存在的数据，会造成数据库的不断查找。  
&emsp;解决方案:  
1.如果数据库不存在，即在缓存中写入一个标志值，例如"$"等，作为标识。这个设定的时间可以较短，例如1分钟。


